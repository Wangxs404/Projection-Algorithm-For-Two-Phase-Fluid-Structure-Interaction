function [ u,v,uL,vL,p,pL,ppie] = D2Eq_Mome(u,v,uL,vL,uf,vf,ufL,vfL,p,mu,rho,rhoL,rhoLL, Mccx, Mccy,psi,phi,sigma,Fe,Fm)
%%  此函数汇总投影法三步，仅指示输入输出即可，所用全局变量均在子函数内声明
global dt D2GradX D2GradY  A_IB EuNeighbor_Index dx DiracMatrix Arc_Length rho_Light
%%
%Step1：FVM计算预测步速度场[U_star，V_star]===============================
[u_star,v_star]=D2Eq_Mome_S1(u,v,uL,vL,uf,vf,ufL,vfL,p,mu,rho,rhoL,rhoLL, Mccx, Mccy,psi,phi,sigma,Fe,Fm);
uL=u;   vL=v;           %为引入BDF二阶，截断储存一次u，v

%% IBM implicit
u_star_EuNeighbor = zeros(length(EuNeighbor_Index.X),1);
v_star_EuNeighbor = zeros(length(EuNeighbor_Index.X),1);

for i=1:length(EuNeighbor_Index.X)
    u_star_EuNeighbor(i)=u_star(EuNeighbor_Index.X(i),EuNeighbor_Index.Y(i));
    v_star_EuNeighbor(i)=v_star(EuNeighbor_Index.X(i),EuNeighbor_Index.Y(i));    
end

RHS_IBM_U = 0 - dx^2 * DiracMatrix * u_star_EuNeighbor;
RHS_IBM_V = 0 - dx^2 * DiracMatrix * v_star_EuNeighbor;

Accelerate_X = A_IB \ RHS_IBM_U;
Accelerate_Y = A_IB \ RHS_IBM_V;


u_correct() = rho_Light*Arc_Length*dt* ;

v_correct() = rho_Light*Arc_Length*dt* ;


%%
%Step2：FVM解Poison方程，计算ppie=========================================
[u_star,v_star]=D2set_BC(u_star,v_star);[p]=D2set_BCNeu(p); 
[ppie] = D2RhieChow3(u_star,v_star,rho,mu,p);
[ppie] = D2set_BCNeu(ppie);%补充一次BC，否则外三层全为0，造成下次循环的P无法使用
pL=p;       %截取pL，用于计算Uf
p=p+ppie;   %基于补充压力算法时，由Ppie计算更新uv，同步更新p用于下次循环的Step1

%% 引入IBM修正

%%
% Step3：计算U_n+1========================================================
[ppie] = D2set_BCNeu(ppie);
u=u_star-(2*dt/3)./rho.*D2GradX(ppie) ; v=v_star-(2*dt/3)./rho.*D2GradY(ppie);

end

